//
// MIT License
// Copyright Pawel Krzywdzinski
//

using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Text;
using Microsoft.CodeAnalysis;

namespace Sharp.UI.Generator;

public class SharpBuilder
{
    GeneratorExecutionContext context;

    public static Dictionary<string, ISymbol> SharpSealedTypeDict { get; private set; }
    public static List<string> InterfaceNameList { get; private set; }

    public SharpBuilder(GeneratorExecutionContext context)
    {
        this.context = context;
    }

    //------------- generate -----------------

    List<String> doneExtensions;


    public bool IsPublicBindableObjectWithConstructor(ISymbol symbol)
    {
        bool isViewObject = false;
        var namedSymbol = symbol as INamedTypeSymbol;

        if (namedSymbol != null &&
            namedSymbol.TypeKind == TypeKind.Class &&
            !namedSymbol.IsGenericType &&
            !namedSymbol.IsAbstract &&
            namedSymbol.DeclaredAccessibility == Accessibility.Public &&
            namedSymbol.ToDisplayString().StartsWith("Microsoft.Maui.Controls") &&
            namedSymbol.Constructors.FirstOrDefault(e => e.DeclaredAccessibility == Accessibility.Public) != null &&
            namedSymbol.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals("ObsoleteAttribute", StringComparison.Ordinal)) == null)
        {

            Helpers.LoopDownToObject(namedSymbol, type =>
            {
                isViewObject = type.ToDisplayString().Equals("Microsoft.Maui.Controls.BindableObject", StringComparison.Ordinal);
                return isViewObject;
            });
        }
        return isViewObject;
    }

    public void Generate()
	{
        doneExtensions = new List<String>();
        SharpSealedTypeDict = new Dictionary<string, ISymbol>();
        InterfaceNameList = new List<string>();

        var mauiSymbolsType = context.Compilation.GetSymbolsWithName(s => true, filter: SymbolFilter.Type)
            .Where(e => e.ToDisplayString().Equals("Sharp.UI.Internal.MauiSymbols")).ToList().FirstOrDefault() as INamedTypeSymbol;

        var mauiSymbols = mauiSymbolsType.GetMembers().Where(e => e.Kind == SymbolKind.Field).Select(e => (e as IFieldSymbol).Type as INamedTypeSymbol).ToList();


        var wrappedSymbols = context.Compilation.GetSymbolsWithName((s) => true, filter: SymbolFilter.Type)
            .Where(e => !e.IsStatic && e.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals(SharpSymbol.SharpObjectAttributeString)) != null);

        var wrappedStaticSymbols = context.Compilation.GetSymbolsWithName((s) => true, filter: SymbolFilter.Type)
            .Where(e => e.IsStatic && e.GetAttributes().FirstOrDefault(e => e.AttributeClass.Name.Equals(SharpSymbol.SharpObjectAttributeString)) != null);

        foreach (var symbol in wrappedSymbols)
        {
            var typeSymbol = (INamedTypeSymbol)symbol;
            var sharpSymbol = new SharpSymbol(typeSymbol);
            if (sharpSymbol.IsWrappedType && sharpSymbol.WrappedType.IsSealed)
                SharpSealedTypeDict[symbol.Name] = symbol;
        }

        //GenerateInterfaces(wrappedSymbols);

        GenerateExtensions(wrappedStaticSymbols);

        //GenerateSymbols(wrappedSymbols);
        GenerateExtensions(wrappedSymbols);
        GenerateWrappedExtensions(wrappedSymbols);
    }

    //------------- generate symbols -----------------


    void GenerateSymbols(IEnumerable<ISymbol> symbols)
    {
        foreach (var symbol in symbols)
        {
            var typeSymbol = (INamedTypeSymbol)symbol;
            var sharpSymbol = new SharpSymbol(typeSymbol);
            this.GenerateSymbol(sharpSymbol);
        }
    }

    void GenerateSymbol(SharpSymbol sharpSymbol)
    {
        var builder = new StringBuilder();
        builder.AppendLine("//");
        builder.AppendLine("// <auto-generated>");
        builder.AppendLine("//");
        builder.AppendLine();
        builder.AppendLine("#pragma warning disable CS8669");
        builder.AppendLine();

        sharpSymbol.BuildClass(builder);

        builder.AppendLine();
        builder.AppendLine();
        builder.AppendLine("#pragma warning restore CS8669");

        context.AddSource(sharpSymbol.ClassBuilderSymbolFileNeme(), builder.ToString());
    }

    //------------- generate extensions -----------------

    void GenerateExtensions(IEnumerable<ISymbol> symbols)
    {
        foreach (var symbol in symbols)
        {
            var sharpSymbol = new SharpSymbol(symbol as INamedTypeSymbol);
            this.GenerateExtension(sharpSymbol);
        }
    }

    void GenerateWrappedExtensions(IEnumerable<ISymbol> symbols)
    {
        foreach (var symbol in symbols)
        {
            var sharpSymbol = new SharpSymbol(symbol as INamedTypeSymbol);
            if (sharpSymbol.IsWrappedType)
            {
                Helpers.LoopDownToObject(sharpSymbol.WrappedType, type =>
                {
                    var baseSharpSymbol = new SharpSymbol(type, symbol as INamedTypeSymbol);
                    var normalizedName = baseSharpSymbol.GetNormalizedName();
                    if (!doneExtensions.Contains(normalizedName))
                    {
                        this.GenerateExtension(baseSharpSymbol);
                        doneExtensions.Add(normalizedName);
                    }
                    return false;
                });
            }
        }
    }

    void GenerateExtension(SharpSymbol sharpSymbol)
    {
        var builder = new StringBuilder();
        builder.AppendLine("//");
        builder.AppendLine("// <auto-generated>");
        builder.AppendLine("//");
        builder.AppendLine();
        builder.AppendLine("#pragma warning disable CS8669");
        builder.AppendLine();

        sharpSymbol.BuildExtension(builder);

        if (sharpSymbol.IsExtensionMethodsGenerated)
        {
            builder.AppendLine();
            builder.AppendLine();
            builder.AppendLine("#pragma warning restore CS8669");

            context.AddSource(sharpSymbol.ExtensionBuilderFileName(), builder.ToString());
        }
    }

    //---------------------------------------------------
    //-------------- generate interfaces ----------------
    //---------------------------------------------------

    //void GenerateInterfaces(IEnumerable<ISymbol> symbols)
    //{
    //    var symbolGroups = symbols.GroupBy(e => e.ContainingNamespace.ToDisplayString());

    //    foreach (var namespaceGroup in symbolGroups)
    //    {

    //        var builder = new StringBuilder();
    //        builder.AppendLine("//");
    //        builder.AppendLine("// <auto-generated>");
    //        builder.AppendLine("//");
    //        builder.AppendLine();
    //        builder.AppendLine($"namespace {namespaceGroup.Key};");
    //        builder.AppendLine();
    //        builder.AppendLine();

    //        InterfaceNameList = new List<string>();

    //        foreach (var symbol in namespaceGroup)
    //        {
    //            var sharpSymbol = new SharpSymbol(symbol as INamedTypeSymbol);
    //            if (sharpSymbol.IsWrappedType)
    //            {
    //                Helpers.LoopDownToObject(sharpSymbol.WrappedType, type =>
    //                {
    //                    var interfaceName = $"I{SharpSymbol.GetNormalizedName(type)}";
    //                    if (!InterfaceNameList.Contains(interfaceName))
    //                    {
    //                        AddInterface(builder, type, namespaceGroup.Key);
    //                        InterfaceNameList.Add(interfaceName);
    //                    }
    //                    return false;
    //                });
    //            }
    //        }

    //        if (InterfaceNameList.Count() > 0)
    //            context.AddSource($"{namespaceGroup.Key}.Interfaces.g.cs", builder.ToString());
    //    }
    //}

    //void AddInterface(StringBuilder builder, INamedTypeSymbol type, string namespaceString)
    //{
    //    var sealedText = type.IsSealed ? " // from sealed class" : "";
    //    var parentInterfaceName = $"I{SharpSymbol.GetNormalizedName(type.BaseType)}";
    //    var parentString = parentInterfaceName.Equals("IObject") ? "" : $" : {namespaceString}.{parentInterfaceName}";
    //    builder.AppendLine($@"public partial interface I{SharpSymbol.GetNormalizedName(type)}{parentString} {{ }}{sealedText}");
    //}
}